# Документация языка программирования FAST

## Введение

**FAST** - это язык функционального программирования общего назначения. 
Он сочетает в себе преимущества динамической типизации, характерной для 
языков, таких как Python и Javascript, и идеи функционального 
программирования, которые активно используются в современных языках 
программирования, таких как F#, Haskell.

Основой языка FAST является формальная система счисления, известная как 
лямбда-исчисление. Эта система позволяет расширять ее, делая совместимой 
с современными ЭВМ, подобно тому, как это делает язык LISP.

## Архитектура языка

Язык FAST состоит из трех модулей: парсера, компилятора и 
интерпретатора. Каждый из этих модулей является самодостаточным и может 
работать независимо.

### Парсер

Задача парсера состоит в разборе входного кода, написанного на языке FAST, и преобразовании его в абстрактное синтаксическое дерево (AST). Полученное AST сохраняется в формате JSON в файл.

### Компилятор

Компилятор преобразует входное AST в низкоуровневое представление программы - лямбда-выражение. Это выражение также сохраняется в файл.

### Интерпретатор

Задача интерпретатора состоит в редуцировании входного лямбда-выражения до конечного значения.

## Низкоуровневая работа

Задача интерпретатора состоит в редуцировании входного лямбда-выражения до конечного результата, путем применения правила редукции. Он основан на идеях eval-apply интерпретатора, который использует язык LISP. Текущая реализация интерпретатора использует инергичную модель вычисления.

### Основные типы данных

На низкоуровневом представлении программы работа происходит со 
следующими основными типами:

- **Константы**: Это низкоуровневые типы, которые представлены в виде 
набора байтов и являются атомарными по своей природе. Примерами таких 
типов являются числа и nil.

- **Лямбда-абстракция**: Это основа вычислительной части 
лямбда-выражений. Они также являются значениями, то есть могут 
передаваться в качестве аргументов. В самом общем виде они представляют 
функцию от одной переменной.

- **Builtin-функции**: Это функции, написанные в императивном стиле в 
виде последовательности инструкций. Внешне работа с ними аналогична 
работе с лямбда-выражениями, однако их тело является абстракцией, то 
есть явно не представлено в виде лямбда-выражения, в отличие от 
лямбда-абстракций. Такие функции необходимы для представления базовых 
операций с атомарными типами данных, таких как целочисленное сложение, 
умножение и т. д.

## Числа

Числа являются **основным типом данных** в языке FAST. Задание значений 
типа число похоже на то, как это реализовано в других языках 
программирования.

**Примеры:**
1. `2`
2. `2672912719`
3. `-1`
4. `0`

На уровне интерпретатора они являются **атомарным типом данных**, то 
есть не представлены в виде составных частей.

Числовой тип данных поддерживает операции целочисленного сложения, 
умножения, вычитания и умножения. Их запись также похоже на общепринятую 
математическую запись.

**Примеры:**
1. `1 + 3` - результатом будет `4`
2. `2 * 3` - результатом будет `6`
3. `5 / 2` - результатом будет `2`
4. `1 - 8` - результатом будет `-7`

Однако, такая запись на самом деле является **синтаксическим сахаром**. 
Более низкоуровнево такие операции представлены в виде функций
`int.add`, `int.sub`, `int.mult`, `int.div`. Поэтому с ними можно 
работать также, как и с другими функциями.

**Примеры:**
1. Запись `1 + 3` эквивалентна `int.add (1, 3)`
2. Запись `2 * 3` эквивалентна `int.mult (2, 3)`
3. Запись `5 / 2` эквивалентна `int.div (5, 2)`
4. Запись `1 - 8` эквивалентна `int.sub (1, 8)`

Также, числовой тип данных поддерживает **базовые операции сравнения**:
1. `{EXPR} == {EXPR}` - операция "равно" для двух чисел.
2. `{EXPR} > {EXPR}` - операция "строго больше"
3. `{EXPR} < {EXPR}` - операция "строго меньше"
4. `{EXPR} >= {EXPR}` - операция "больше или равно"
5. `{EXPR} <= {EXPR}` - операция "меньше или равно"
6. `{EXPR} <> {EXPR}` - операция "не равно"

Аналогично целочисленным операциям, низкоуровнево операции сравнения 
представлены в виде функций `const.equal`, `int.greater`, `int.lower`, 
`int.lower_equal`, `int.greater_equal`.

## Тип `nil`

Тип `nil` - это специальный тип данных, который описывает отсутствие значения. Он аналогичен значению `None` в языке Python или `null` в C#. Этот тип данных не поддерживает операции, за исключением операции сравнения.

## Тип `string`

FAST поддерживает строки как один из своих типов данных. Строка в FAST представляет собой последовательность символов.

Присвоение значения строке выглядит следующим образом:
```
let x = "hello world"
```

### Операции над строками

FAST предоставляет ряд операций для работы со строками:

- `string.ord(string)` - преобразует символ в его ASCII код. Принимает на вход 
строку, состоящую из одного символа, и возвращает число, представляющее ASCII код 
этого символа.

- `string.chr(int)` - преобразует ASCII код в соответствующий символ. Принимает на 
вход число, представляющее ASCII код, и возвращает строку, состоящую из одного 
символа, соответствующего этому коду.

- `string.get(string, int)` - возвращает символ из строки по указанному индексу. 
Принимает на вход строку и индекс символа. Если индекс выходит за границы строки, 
генерируется ошибка. Возвращает строку, состоящую из одного символа, найденного в 
исходной строке.

- `string.len(string)` - возвращает длину строки. Принимает на вход строку и 
возвращает число, равное количеству символов в строке.

- `string.concat(string, string)` - объединяет две строки в одну. Принимает на вход 
две строки и возвращает новую строку, являющуюся результатом их объединения.

### Конкатенация строк

В FAST для строк определена операция `+`, которая является альтернативой функции 
`string.concat`.

**Пример:**
```
let result = "abc" + "def"
```

В результате выполнения данного выражения будет получена строка `abcdef`, что 
эквивалентно вызову `string.concat("abc", "def")`.

## Сравнение атомарных типов

Для всех атомарных типов предусмотрена операция сравнения `const.equal` 
(или `==` в виде операции). Эта операция полиморфна по отношению к 
атомарному типу, что означает, что она может быть применена к любым двум 
атомарным типам. Она возвращает истинное значение, если два атомарных 
значения идентичны, и ложное значение в противном случае.

Аналогично, к любым атомарным типам может быть применена операция проверки на **не**соответствия `<>`.

**Примеры:**
1. `1 == 2` - вернет "ложь", так как операнды разные
2. `1 == 1` - вернет "истину", так как операнды идентичны
3. `nil == 1` - вернет "ложь", так как операнды разные
4. `nil == nil` - вернет "истину", так как операнды идентичны
5. `1 <> nil` - вернет "истину", так как операнды различны
5. `nil <> nil` - вернет "ложь", так как опернады идентичны

## Булевский тип

Булевский тип представлен двумя значениями: `true` (истина) и `false` (ложь).

Булевский тип поддерживает следующие операции:

1. `||` (`bool.or`) - операция "логическое ИЛИ". Возвращает `true`, если хотя бы один из двух аргументов равен `true`.
2. `&&` (`bool.and`) - операция "логическое И". Возвращает `true`, если оба аргумента равны `true`.
3. `!` (`bool.not`) - операция "логическое НЕ". Возвращает `true`, если аргумент равен `false`, и наоборот.

## Именованные переменные

Для создания переменных в языке FAST используется конструкция с ключевым словом `let`:

```
let {NAME} = {EXPR}
```

где `{NAME}` - это название переменной, а `{EXPR}` - это значение переменной, которое может быть представлено как в виде константы, так и в виде выражения.

### Требования к названию переменной

1. Название не может быть ключевым словом.
2. Название не может начинаться с цифры.
3. Название не должно содержать пробелов.

Как было описано ранее, значение переменной может быть любым выражением, поддерживаемым языком программирования.

**Примеры:**
1. `let x = 1`
2. `let myVariable = nil`
3. `let snake_case_variable = 2`
4. `let x = 2 + 3 * 6`

Переменные могут использоваться в качестве значений во всех выражениях, 
находящихся ниже объявления переменной на том же уровне, на котором она 
была объявлена.

**Пример:**
```
let x = 56,
let y = x + 8,
let z = x + y * x
```

Переменные также могут иметь одинаковые имена. В этом случае новое объявление переменной будет "перекрывать" старое.

**Пример:**
```
let x = 8,
let y = x + 10,
let x = 10,
let z = x + 10
```

В этом примере в переменной `y` будет лежать значение `18`, так как для нее переменная `x` хранит значение `8`, в то время как в переменной `z` будет значение `20`, так как для нее переменная `x` хранит значение `10`.

## Условные выражения

Язык программирования FAST поддерживает ветвления. Их запись схожа с 
записью в других языках программирования:

```
if {CONDITION} then
    {POSITIVE BRANCH}
else
    {NEGATIVE BRANCH}
```

где `{CONDITION}` - это выражение, представляющее условие для ветвления, 
`{POSITIVE BRANCH}` - это выражение, которое будет выбрано при 
выполнении условия, и `{NEGATIVE BRANCH}` - это выражение, которое будет 
выбрано при невыполнении условия.

> **Важно отметить**, что сами выражения вычисляются **лениво**. Это 
> означает, что сначала выполняется условие, и в зависимости от > результата будет выполнена та или иная ветвь.

> Отличие этой записи от записи в императивных языках программирования 
> заключается в том, что ветвь `else` обязательна. Это связано с тем, 
> что в функциональном программировании выражение должно всегда иметь 
> результат, а при отсутствии ветки `else` неизвестно, какой результат 
> будет при невыполнении условия.

# Документация языка программирования FAST

## Функции

### Анонимные функции

В функциональном программировании функция рассматривается как объект 
первого класса. Это означает, что функция может быть использована в 
контексте значения: передаваться в качестве аргумента, сохраняться в 
переменную и т.д. Поэтому язык программирования также поддерживает 
анонимное задание функции:

```
[{ARG 1}, {ARG 2}, ...] :> {EXPR}
```

где `{ARG N}` - это аргументы функции, а `{EXPR}` - это тело функции.

**Пример:**
```
let foo = [x, y] :> x + y
```

### Именованные функции

Для случая, когда функция имеет название, предусмотрен альтернативный 
способ задания именованной функции:

```
def {NAME}({ARG 1}, {ARG 2}, ...) {EXPR}
```

где `{NAME}` - это название функции, `{ARG N}` - это аргументы функции, 
и `{EXPR}` - это тело функции.

**Пример:**
```
def foo(x, y) {
    let z = x + y,
    z + 2
}
```

### Рекурсия

Именованные функции позволяют использовать рекурсию, так как такая 
запись уже предусматривает указание названия функции, по которому можно 
обращаться. Это означает, что в теле именованной функции можно вызывать 
саму же ее, подобно языку Python, C++ и т.д.

**Пример:**
```
def fact(n) {
    if n == 0 then 1
    else n * fact(n - 1)
},
fact(5)
```

### Замыкания

Также функции поддерживают замыкания. Это означает, что внутри тела 
функции могут быть использованы переменные, объявленные на уровнях выше.

**Пример:**
```
let foo = [x, y] :> x + y,
let bar = [x] :> [y] :> foo (x, y)
```

### Механизм ленивых вычислений

Язык программирования FAST поддерживает ленивые вычисления, аналогичные тем, что 
присутствуют в языке F#. Ленивые вычисления позволяют отложить выполнение 
вычислительного выражения до момента, когда его результат действительно потребуется.

Для реализации ленивого вычисления в FAST, выражение должно быть обернуто в функцию, которая принимает один фиктивный аргумент, обозначаемый как `_`.

**Пример:**
```
let x = 8,
let lazy_function = [_] :> x + 3
```

В данном примере, `lazy_function` является функцией, которая откладывает вычисление 
выражения `x + 3`. Вычисление начнется только тогда, когда функция будет вызвана. 
Вызов функции осуществляется без передачи аргументов.

**Пример:**
```
let result = lazy_function()
```

В результате, значение `result` будет равно `11`, что является результатом вычисления 
отложенного выражения `x + 3`.


### Каррирование

В функциональном программировании функции обычно поддерживают концепцию 
частичного применения аргументов, которая называется **каррирование**. 

Язык  FAST не является исключением! В языке FAST вы также можете 
применить к функции часть аргументов. Результатом будет функция, с 
оставшимися аргументами

```
def foo(x, y) { x + y },
let bar = foo(1),
bar(2)
```

## Списки

Стандартная библиотека FAST поддерживает такой тип данных, как списки. 
Списки представлены в виде пары "голова", "хвост".

Задание списка: `[{VALUE 1}; {VALUE 2}; ...]`, где `{VALUE N}` - элемент 
списка, представленный в виде выражения.

**Примеры:**
1. `[1; 2; 3; 4; 5]`
2. `[1 + 2; 3 + 4; 5 + 6]`
3. `[[1; 3]; [3; 4]; [4; 5]]`

Списки поддерживают следующие операции:

- `list.empty(L)` - определяет, пустой ли список.
- `list.insert(el, L)` - вставляет элемент `el` в начало списка `L`.
- `list.head(L)` - получение "головы" списка. Возвращает `nil`, если список пустой.
- `list.tail(L)` - получение "хвоста" списка. Возвращает `nil`, если список пустой.

**Пример:**
```
def list_sum(L) {
    if list.empty(L) then 0
    else list.head(L) + list_sum(list.tail(L))
},
list_sum([1; 2; 3; 4; 5])
```

## Ввод/вывод

Стандартная библиотека FAST поддерживает возможность ввода и вывода информации через консоль.

Список поддерживаемых операций:

- `print(text)` - выводит в консоль text.
- `printn(text)` - выводит в консоль text с новой строки.
- `input()` - использует консоль для чтения строки, введённой пользователем, и возвращает её как String.

**Вывод**

```
print("abracadabra")
printn("new abracadabra")
```

**Ввод**
```
let text = input()
printn(text)
```


## Файлы

Стандартная библиотека FAST поддерживает возможность взаимодействия с файлами

Список поддерживаемых операций:

- file.read(path) - возвращает всё содержимое файла по пути path.
- file.write(path, content) - менят всё содержимое файла на текст content. Если файл по пути path отсутствует, будет создан новый. Возвращает nil
- file.append(path, content) - добавляет в конец файла текст content. Если файл по пути path отсутствует, будет создан новый. Возвращает nil

**Запись в файл:**

```
file.write("C:/user/file.txt", "hello world")
```

**Чтение из файла:**

```
let content = file.read("C:/user/file.txt")
string.len(content)
```

**Добавление текста в файл:**

```
let content = file.read("file.txt")
file.append("file.txt", "\nrepeat: " + content)
```


## Примеры использования

### Пример 1: Факториал

```
def fact(n) {
    if n == 0 then 1
    else n * fact(n - 1)
},
fact(5)
```

### Пример 2: Функции первого порядка

```
def foo(f) f(2, 3),
def bar(x, y) x + y,
foo(bar)
```

### Пример 3: Цикл for

```
def for(f, a, b, init_state) {
    def _step(n, state) {
        if n == b then state
        else _step(n + 1, f(n, state))
    },
    _step(a, init_state)
},

def foo(n, s) s + n,
for(foo, 1, 5, 0)
```

### Пример 4: Функция reduce

```
def reduce(f, L, init_val) {
    if list.empty(L) then init_val
    else f(list.head(L), reduce(f, list.tail(L), init_val))
},
let arr = [1; 2; 3; 4; 5],
def mul(x, y) {x * y},
reduce(mul, arr, 1)
```
