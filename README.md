# Документация языка программирования FAST

## Введение

**FAST** - это язык функционального программирования общего назначения. 
Он сочетает в себе преимущества динамической типизации, характерной для 
языков, таких как Python и Javascript, и идеи функционального 
программирования, которые активно используются в современных языках 
программирования, таких как F#, Haskell.

Основой языка FAST является формальная система счисления, известная как 
лямбда-исчисление. Эта система позволяет расширять ее, делая совместимой 
с современными ЭВМ, подобно тому, как это делает язык LISP.

## Установка

### Установка языка

#### .NET Сборка

Для сборки .NET проекта вам потребуется .NET SDK. Если у вас его еще нет,
вы можете скачать его с официального сайта Microsoft. Минимальная
требуемая версия .NET SDK - 7.0.

1. Склонируйте репозиторий на локальное устройство через `git clone`
   и перейдите в установленную директорию проекта.
2. Перейдите в директорию `CliTool` с помощью команды `cd CliTool`
3. Выполните сборку с помощью команды `dotnet build`
4. В директории `bin` находится собранный проект. Он содержит исполняемый файл
   с названием `fast`. С ним будет происходить дальнейшее взаимодействие.

#### Windows

Для установки языка FAST на ОС Windows необходимо скачать установщик
на [странице релизов](https://github.com/MAILabs-Edu-2024/fp-compiler-lab-_/releases)

1. При установке выберите удобное для вас расположение данных скачиваемой
   утилиты.

2. После успешной установки добавьте в переменную окружения `PATH` путь
   к директории установленной утилиты

3. Для проверки введите в окне терминала `fast --help`

#### Linux

Для установки языка FATS на ОС Ubuntu необходимо скачать DEB пакет
на [странице релизов](https://github.com/MAILabs-Edu-2024/fp-compiler-lab-_/releases)

1. Установите утилиту с помощью команды `sudo apt install path/to/fast.deb`.
   Возможно, потребуются права администратора. Если вы используете относительный
   путь до DEB пакета, важно явно указать префикс `./`

2. Проверьте установку, найдя среди установленных пакетов с помощью команды
   `apt list --installed` утилиту `fast-lang`

3. Проверьте работоспособность утилиты с помощью команды `fast --help`

### Установка расширения

Для установки VS Code расширения для языка FAST необхоимо выполнить следующие
действия:

1. Скачайте VSIX пакет на [странице релизов](https://github.com/MAILabs-Edu-2024/fp-compiler-lab-_/releases)

2. Перейдите в VS Code во вкладку `Extensions`

3. Нажмите на иконку `...` в углу окна расширений и выберите пункт `Instal from VSIX...`

4. Укажите путь на установленный VSIX пакет

> **Note:**
> Более подробно процесс работы с VS Code расширением для языка FAST описан [здесь](https://github.com/polzzzik/FP_compiler_lab/blob/main/extension.md)

## Архитектура языка

Язык FAST состоит из трех модулей: парсера, компилятора и 
интерпретатора. Каждый из этих модулей является самодостаточным и может 
работать независимо.

### Парсер

Задача парсера состоит в разборе входного кода, написанного на языке FAST,
и преобразовании его в абстрактное синтаксическое дерево (AST). Полученное
AST сохраняется в формате JSON в файл.

### Компилятор

Компилятор преобразует входное AST в низкоуровневое представление программы -
лямбда-выражение. Это выражение также сохраняется в файл.

### Интерпретатор

Задача интерпретатора состоит в редуцировании входного лямбда-выражения до
конечного значения.

## Низкоуровневая работа

Задача интерпретатора состоит в редуцировании входного лямбда-выражения до
конечного результата, путем применения правила редукции. Он основан на идеях
eval-apply интерпретатора, который использует язык LISP. Текущая реализация
интерпретатора использует инергичную модель вычисления.

### Основные типы данных

На низкоуровневом представлении программы работа происходит со 
следующими основными типами:

- **Константы**: Это низкоуровневые типы, которые представлены в виде 
набора байтов и являются атомарными по своей природе. Примерами таких 
типов являются числа и nil.

- **Лямбда-абстракция**: Это основа вычислительной части 
лямбда-выражений. Они также являются значениями, то есть могут 
передаваться в качестве аргументов. В самом общем виде они представляют 
функцию от одной переменной.

- **Builtin-функции**: Это функции, написанные в императивном стиле в 
виде последовательности инструкций. Внешне работа с ними аналогична 
работе с лямбда-выражениями, однако их тело является абстракцией, то 
есть явно не представлено в виде лямбда-выражения, в отличие от 
лямбда-абстракций. Такие функции необходимы для представления базовых 
операций с атомарными типами данных, таких как целочисленное сложение, 
умножение и т. д.

## Числа

Числа являются **основным типом данных** в языке FAST. Задание значений 
типа число похоже на то, как это реализовано в других языках 
программирования.

**Примеры:**
1. `2`
2. `2672912719`
3. `-1`
4. `0`

На уровне интерпретатора они являются **атомарным типом данных**, то 
есть не представлены в виде составных частей.

Числовой тип данных поддерживает операции целочисленного сложения, 
умножения, вычитания и умножения. Их запись также похоже на общепринятую 
математическую запись.

**Примеры:**
1. `1 + 3` - результатом будет `4`
2. `2 * 3` - результатом будет `6`
3. `5 / 2` - результатом будет `2`
4. `1 - 8` - результатом будет `-7`

Однако, такая запись на самом деле является **синтаксическим сахаром**. 
Более низкоуровнево такие операции представлены в виде функций
`int.add`, `int.sub`, `int.mult`, `int.div`. Поэтому с ними можно 
работать также, как и с другими функциями.

**Примеры:**
1. Запись `1 + 3` эквивалентна `int.add (1, 3)`
2. Запись `2 * 3` эквивалентна `int.mult (2, 3)`
3. Запись `5 / 2` эквивалентна `int.div (5, 2)`
4. Запись `1 - 8` эквивалентна `int.sub (1, 8)`

Также, числовой тип данных поддерживает **базовые операции сравнения**:
1. `{EXPR} == {EXPR}` - операция "равно" для двух чисел.
2. `{EXPR} > {EXPR}` - операция "строго больше"
3. `{EXPR} < {EXPR}` - операция "строго меньше"
4. `{EXPR} >= {EXPR}` - операция "больше или равно"
5. `{EXPR} <= {EXPR}` - операция "меньше или равно"
6. `{EXPR} <> {EXPR}` - операция "не равно"

Аналогично целочисленным операциям, низкоуровнево операции сравнения 
представлены в виде функций `const.equal`, `int.greater`, `int.lower`, 
`int.lower_equal`, `int.greater_equal`.

## Тип `nil`

Тип `nil` - это специальный тип данных, который описывает отсутствие значения.
Он аналогичен значению `None` в языке Python или `null` в C#. Этот тип данных
не поддерживает операции, за исключением операции сравнения.

## Тип `string`

FAST поддерживает строки как один из своих типов данных. Строка в FAST представляет
собой последовательность символов.

Присвоение значения строке выглядит следующим образом:
```
let x = "hello world"
```

### Операции над строками

FAST предоставляет ряд операций для работы со строками:

- `string.ord(string)` - преобразует символ в его ASCII код. Принимает на вход 
строку, состоящую из одного символа, и возвращает число, представляющее ASCII код 
этого символа.

- `string.chr(int)` - преобразует ASCII код в соответствующий символ. Принимает на 
вход число, представляющее ASCII код, и возвращает строку, состоящую из одного 
символа, соответствующего этому коду.

- `string.get(string, int)` - возвращает символ из строки по указанному индексу. 
Принимает на вход строку и индекс символа. Если индекс выходит за границы строки, 
генерируется ошибка. Возвращает строку, состоящую из одного символа, найденного в 
исходной строке.

- `string.len(string)` - возвращает длину строки. Принимает на вход строку и 
возвращает число, равное количеству символов в строке.

- `string.concat(string, string)` - объединяет две строки в одну. Принимает на вход 
две строки и возвращает новую строку, являющуюся результатом их объединения.

### Конкатенация строк

В FAST для строк определена операция `+`, которая является альтернативой функции 
`string.concat`.

**Пример:**
```
let result = "abc" + "def"
```

В результате выполнения данного выражения будет получена строка `abcdef`, что 
эквивалентно вызову `string.concat("abc", "def")`.

## Сравнение атомарных типов

Для всех атомарных типов предусмотрена операция сравнения `const.equal` 
(или `==` в виде операции). Эта операция полиморфна по отношению к 
атомарному типу, что означает, что она может быть применена к любым двум 
атомарным типам. Она возвращает истинное значение, если два атомарных 
значения идентичны, и ложное значение в противном случае.

Аналогично, к любым атомарным типам может быть применена операция проверки на **не**соответствия `<>`.

**Примеры:**
1. `1 == 2` - вернет "ложь", так как операнды разные
2. `1 == 1` - вернет "истину", так как операнды идентичны
3. `nil == 1` - вернет "ложь", так как операнды разные
4. `nil == nil` - вернет "истину", так как операнды идентичны
5. `1 <> nil` - вернет "истину", так как операнды различны
5. `nil <> nil` - вернет "ложь", так как опернады идентичны

## Булевский тип

Булевский тип представлен двумя значениями: `true` (истина) и `false` (ложь).

Булевский тип поддерживает следующие операции:

1. `||` (`bool.or`) - операция "логическое ИЛИ". Возвращает `true`, если хотя бы один из двух аргументов равен `true`.
2. `&&` (`bool.and`) - операция "логическое И". Возвращает `true`, если оба аргумента равны `true`.
3. `!` (`bool.not`) - операция "логическое НЕ". Возвращает `true`, если аргумент равен `false`, и наоборот.

## Именованные переменные

Для создания переменных в языке FAST используется конструкция с ключевым словом `let`:

```
let {NAME} = {EXPR}
```

где `{NAME}` - это название переменной, а `{EXPR}` - это значение переменной,
которое может быть представлено как в виде константы, так и в виде выражения.

### Требования к названию переменной

1. Название не может быть ключевым словом.
2. Название не может начинаться с цифры.
3. Название не должно содержать пробелов.

Как было описано ранее, значение переменной может быть любым выражением,
поддерживаемым языком программирования.

**Примеры:**
1. `let x = 1`
2. `let myVariable = nil`
3. `let snake_case_variable = 2`
4. `let x = 2 + 3 * 6`

Переменные могут использоваться в качестве значений во всех выражениях, 
находящихся ниже объявления переменной на том же уровне, на котором она 
была объявлена.

**Пример:**
```
let x = 56,
let y = x + 8,
let z = x + y * x
```

Переменные также могут иметь одинаковые имена. В этом случае новое объявление
переменной будет "перекрывать" старое.

**Пример:**
```
let x = 8,
let y = x + 10,
let x = 10,
let z = x + 10
```

В этом примере в переменной `y` будет лежать значение `18`, так как для нее
переменная `x` хранит значение `8`, в то время как в переменной `z` будет
значение `20`, так как для нее переменная `x` хранит значение `10`.

## Условные выражения

Язык программирования FAST поддерживает ветвления. Их запись схожа с 
записью в других языках программирования:

```
if {CONDITION} then
    {POSITIVE BRANCH}
else
    {NEGATIVE BRANCH}
```

где `{CONDITION}` - это выражение, представляющее условие для ветвления, 
`{POSITIVE BRANCH}` - это выражение, которое будет выбрано при 
выполнении условия, и `{NEGATIVE BRANCH}` - это выражение, которое будет 
выбрано при невыполнении условия.

> **Важно отметить**, что сами выражения вычисляются **лениво**. Это 
> означает, что сначала выполняется условие, и в зависимости от результата
> будет выполнена та или иная ветвь.

> Отличие этой записи от записи в императивных языках программирования 
> заключается в том, что ветвь `else` обязательна. Это связано с тем, 
> что в функциональном программировании выражение должно всегда иметь 
> результат, а при отсутствии ветки `else` неизвестно, какой результат 
> будет при невыполнении условия.

# Документация языка программирования FAST

## Функции

### Анонимные функции

В функциональном программировании функция рассматривается как объект 
первого класса. Это означает, что функция может быть использована в 
контексте значения: передаваться в качестве аргумента, сохраняться в 
переменную и т.д. Поэтому язык программирования также поддерживает 
анонимное задание функции:

```
[{ARG 1}, {ARG 2}, ...] :> {EXPR}
```

где `{ARG N}` - это аргументы функции, а `{EXPR}` - это тело функции.

**Пример:**
```
let foo = [x, y] :> x + y
```

### Именованные функции

Для случая, когда функция имеет название, предусмотрен альтернативный 
способ задания именованной функции:

```
def {NAME}({ARG 1}, {ARG 2}, ...) {EXPR}
```

где `{NAME}` - это название функции, `{ARG N}` - это аргументы функции, 
и `{EXPR}` - это тело функции.

**Пример:**
```
def foo(x, y) {
    let z = x + y,
    z + 2
}
```

### Рекурсия

Именованные функции позволяют использовать рекурсию, так как такая 
запись уже предусматривает указание названия функции, по которому можно 
обращаться. Это означает, что в теле именованной функции можно вызывать 
саму же ее, подобно языку Python, C++ и т.д.

**Пример:**
```
def fact(n) {
    if n == 0 then 1
    else n * fact(n - 1)
},
printn(repr(fact(5)))
```

### Замыкания

Также функции поддерживают замыкания. Это означает, что внутри тела 
функции могут быть использованы переменные, объявленные на уровнях выше.

**Пример:**
```
let foo = [x, y] :> x + y,
let bar = [x] :> [y] :> foo (x, y)
```

### Механизм ленивых вычислений

Язык программирования FAST поддерживает ленивые вычисления, аналогичные тем, что 
присутствуют в языке F#. Ленивые вычисления позволяют отложить выполнение 
вычислительного выражения до момента, когда его результат действительно потребуется.

Для реализации ленивого вычисления в FAST, выражение должно быть обернуто в функцию, которая принимает один фиктивный аргумент, обозначаемый как `_`.

**Пример:**
```
let x = 8,
let lazy_function = [_] :> x + 3
```

В данном примере, `lazy_function` является функцией, которая откладывает вычисление 
выражения `x + 3`. Вычисление начнется только тогда, когда функция будет вызвана. 
Вызов функции осуществляется без передачи аргументов.

**Пример:**
```
let result = lazy_function()
```

В результате, значение `result` будет равно `11`, что является результатом вычисления 
отложенного выражения `x + 3`.


### Каррирование

В функциональном программировании функции обычно поддерживают концепцию 
частичного применения аргументов, которая называется **каррирование**. 

Язык  FAST не является исключением! В языке FAST вы также можете 
применить к функции часть аргументов. Результатом будет функция, с 
оставшимися аргументами

```
def foo(x, y) { x + y },
let bar = foo(1),
printn(repr(bar(2)))
```

## Списки

Стандартная библиотека FAST поддерживает такой тип данных, как списки. 
Списки представлены в виде пары "голова", "хвост".

Задание списка: `[{VALUE 1}; {VALUE 2}; ...]`, где `{VALUE N}` - элемент 
списка, представленный в виде выражения.

**Примеры:**
1. `[1; 2; 3; 4; 5]`
2. `[1 + 2; 3 + 4; 5 + 6]`
3. `[[1; 3]; [3; 4]; [4; 5]]`

Списки поддерживают следующие операции:

- `list.empty(L)` - определяет, пустой ли список.
- `list.insert(el, L)` - вставляет элемент `el` в начало списка `L`.
- `list.head(L)` - получение "головы" списка. Возвращает `nil`, если список пустой.
- `list.tail(L)` - получение "хвоста" списка. Возвращает `nil`, если список пустой.
- `list.reduce(L, f, init)` - "сжатие" списка `L` с использованием функции `f`
  и начального значения `init`. Является аналогом записи `f(a1, f(a2, f(..., f(an, init))))`
- `list.map(L, f)` - применяет функцию `f` ко всем элементам списка `L`. Возвращает список
  элементами которого являются значения функции `f`: `[f(a1); f(a2); ...]`
- `list.filter(L, f)` - фильрация элементов списка на основе функции-предиката `f`,  которая
  применяет на вход элемент списка и возвращает булево значение. Возвращает список с элементами,
  для которых функция-предикат вернула истинное значение.
- `list.get(L, index)` - получение элемента списка `L` по индексу `index`. Если `index` выходит
  за рамки списка, то возвращается значение `nil`.
- `list.len(L)` - длина списка `L`. Возвращает число, соответствующее количеству элементов в списке. 

**Пример:**
```
def list_sum(L) {
    if list.empty(L) then 0
    else list.head(L) + list_sum(list.tail(L))
},
printn(repr(list_sum([1; 2; 3; 4; 5])))
```

## Последовательности

Последовательности представляют собой объекты, которые позволяет поэтапно получать элемент
за элементом. Их отличие от списков заключается в том, что элементы вычисляются лениво, что,
например, позволяет реализовать бесконечную цепочку.

### Создание последовательностей

Для создания последовательностей предусмотрено 2 функции:
- `seq.range(a, b)` - генерация конечной последовательности целых чисел в диапазоне `[a; b)` (не включительно!)
- `seq.count(start)` - генерация бесконечной последовательности целых чисел, начиная с числа `start`

**Пример:**
```
let x = seq.range(1, 5),
ler y = seq.count(5)
```

### Вспомогательные функции

Также, стандартная библиотека FAST поддерживает следующие функции для работы с последовательностями:
- `seq.get(s)` - получение текущего элемента последовательности `s`. Если последовательность пустая,
  то возвращается значение `nil`. Функция является идемпотентной по отношению к последовательности,
  то есть, сохраняется отношение `seq.get(s) == seq.get(s)`
- `seq.next(s)` - переход к следующему элементу последовательности `s`. Возвращает последовательность,
  у которой первым элементом является следующий в `s`. Функция также является идемпотентной по отношению
  к подоваемой на вход последовательности.
- `seq.is_end(s)` - определение, является ли последовательность пустой.
- `seq.map(s, f)` - применение функции `f` к элементам последовательности `s`. Возвращает последовательность,
  элементами которой являются значения функции `f`: `{f(a1), f(a2), ...}`
- `seq.reduce(s, f, init)` -  "сжатие" последовательности `s` с использованием функции `f`
  и начального значения `init`. Является аналогом записи `f(seq.get(s), f(seq.get(seq.next(s)), ...)`.
  Применима только для конечных последовательностей
- `seq.take(s, n)` - получение первых `n` элементов из последовательности `s`. Возвращает последовательность,
  содержащую первые `n` элементов. Если `n` превышает длину последовательности, то возвращается вся последовательность,
  и итоговая длина результирующей последовательности становится меньше `n`

**Пример:**
```
let s = seq.range(1, 10),
let res = seq.reduce(s, int.add, 0),
printn(repr(res))
```

**Пример:**
```
def repr_seq(s) seq.reduce (s, [el, val] :> repr(el) + ", " + val, ""),
let s = seq.range(1, 20),
printn(repr_seq(s))
```

**Пример:**
```
def repr_seq(s) seq.reduce (s, [el, val] :> repr(el) + ", " + val, ""),
def fib(n) {
    if n == 0 then 0
    else if n == 1 then 1
    else fib(n - 1) + fib(n - 2)
},
let s = seq.count(1),
let a = seq.map(s, fib),
let b = seq.take(a, 10),
printn(repr_seq(b))
```

## Ввод/вывод

Стандартная библиотека FAST поддерживает возможность ввода и вывода информации через консоль.

Список поддерживаемых операций:

- `print(text)` - выводит в консоль text.
- `printn(text)` - выводит в консоль text с новой строки.
- `input()` - использует консоль для чтения строки, введённой пользователем, и возвращает её как String.

**Вывод**

```
print("abracadabra")
printn("new abracadabra")
```

**Ввод**
```
let text = input()
printn(text)
```

## Файлы

Стандартная библиотека FAST поддерживает возможность взаимодействия с файлами

Список поддерживаемых операций:

- file.read(path) - возвращает всё содержимое файла по пути path.
- file.write(path, content) - менят всё содержимое файла на текст content. Если файл по пути path отсутствует, будет создан новый. Возвращает nil
- file.append(path, content) - добавляет в конец файла текст content. Если файл по пути path отсутствует, будет создан новый. Возвращает nil

**Запись в файл:**

```
file.write("C:/user/file.txt", "hello world")
```

**Чтение из файла:**

```
let content = file.read("C:/user/file.txt")
printn(repr(string.len(content)))
```

**Добавление текста в файл:**

```
let content = file.read("file.txt")
file.append("file.txt", "\nrepeat: " + content)
```

## Импорты

Язык FAST также поддерживает разработку программ, написанных в разных файлах.
Для этого существует механизм импортов файлов, похожий на тот, что использует
язык C, C++.

Импорт файлов записывается в коде в виде выражения следующего формата
```
import "path/to/file"
```
где после ключевого слова `import` идет строковое представление пути к файлу
без расширения.

Например, если ваша программа состоит из двух файлов `project/a.fast` и `project/b.fast`,
то импорт файла `b.fast` в файле `a.fast` будет происходить следующим образом

```
import "b",
<some code here...>
```

### Разыменование путей

При импорте препроцессор языка FAST пытается сопоставить текущему пути конкретный путь к файлу
следующим образом:
- **Поиск относительно файла**. Первым шагом является поиск относительно импортирующего файла.
  Например, если в файле `some/example/path/a.fast` происходит импорт `import "../b"`, то
  препроцессор попытаеся найти файл `some/example/b.fast`.
- **Поиск в стандартной библиотеке**. Если не удалось найти файл относительно импортирующего, то
  препроцессор будет пытаться найти файл в стандартной библиотеке FAST, которая находится
  по пути `{SOURCE_DIR}/lib`, где `{SOURCE_DIR}` - путь к директории с исполняемой cli tool.

**Пример:**
```
a.fast
---
import "b",
let x = y + 20,
printn(repr(x))

b.fast
---
let y = 40
```

## Примеры использования

### Пример 1: Факториал

```
def fact(n) {
    if n == 0 then 1
    else n * fact(n - 1)
},
printn(repr(fact(5)))
```

### Пример 2: Функции первого порядка

```
def foo(f) f(2, 3),
def bar(x, y) x + y,
printn(repr(foo(bar)))
```

### Пример 3: Цикл for

```
def for(f, a, b, init_state) {
    def _step(n, state) {
        if n == b then state
        else _step(n + 1, f(n, state))
    },
    _step(a, init_state)
},

def foo(n, s) s + n,
printn(repr(for(foo, 1, 5, 0)))
```

### Пример 4: Функция reduce

```
def reduce(f, L, init_val) {
    if list.empty(L) then init_val
    else f(list.head(L), reduce(f, list.tail(L), init_val))
},
let arr = [1; 2; 3; 4; 5],
def mul(x, y) {x * y},
printn(repr(reduce(mul, arr, 1)))
```
